{"ast":null,"code":"const getAbsolutePath = (basePath, relativePath) => {\n  if (relativePath[0] !== '.') {\n    return relativePath;\n  }\n\n  var stack = basePath.split('/');\n  var chunks = relativePath.split('/');\n  stack.pop();\n\n  for (var i = 0; i < chunks.length; i++) {\n    if (chunks[i] == '.') {\n      continue;\n    } else if (chunks[i] == '..') {\n      stack.pop();\n    } else {\n      stack.push(chunks[i]);\n    }\n  }\n\n  return stack.join('/');\n};\n\nconst getImportPath = (currentLocation, importLocation) => {\n  let path = getAbsolutePath(currentLocation, importLocation);\n  const extension = path.slice((path.lastIndexOf(\".\") - 1 >>> 0) + 2);\n  return extension ? path : path.concat('.zok');\n};\n\nmodule.exports = dep => {\n  const {\n    zokrates,\n    stdlib\n  } = dep;\n\n  const resolveFromStdlib = (currentLocation, importLocation) => {\n    let key = getImportPath(currentLocation, importLocation);\n    let source = stdlib[key];\n    return source ? {\n      source,\n      location: key\n    } : null;\n  };\n\n  return {\n    compile: (source, options = {}) => {\n      const {\n        location = \"main.zok\",\n        resolveCallback = () => null\n      } = options;\n\n      const callback = (currentLocation, importLocation) => {\n        return resolveFromStdlib(currentLocation, importLocation) || resolveCallback(currentLocation, importLocation);\n      };\n\n      const {\n        program,\n        abi\n      } = zokrates.compile(source, location, callback);\n      return {\n        program: Array.from(program),\n        abi\n      };\n    },\n    setup: program => {\n      const {\n        vk,\n        pk\n      } = zokrates.setup(program);\n      return {\n        vk,\n        pk: Array.from(pk)\n      };\n    },\n    computeWitness: (artifacts, args) => {\n      return zokrates.compute_witness(artifacts, JSON.stringify(Array.from(args)));\n    },\n    exportSolidityVerifier: (verificationKey, abiVersion) => {\n      return zokrates.export_solidity_verifier(verificationKey, abiVersion);\n    },\n    generateProof: (program, witness, provingKey) => {\n      return zokrates.generate_proof(program, witness, provingKey);\n    },\n    verify: (verificationKey, proof) => {\n      return zokrates.verify(verificationKey, proof);\n    }\n  };\n};","map":{"version":3,"sources":["/home/matias/Memoria/Demo/front-zk/app/node_modules/zokrates-js/wrapper.js"],"names":["getAbsolutePath","basePath","relativePath","stack","split","chunks","pop","i","length","push","join","getImportPath","currentLocation","importLocation","path","extension","slice","lastIndexOf","concat","module","exports","dep","zokrates","stdlib","resolveFromStdlib","key","source","location","compile","options","resolveCallback","callback","program","abi","Array","from","setup","vk","pk","computeWitness","artifacts","args","compute_witness","JSON","stringify","exportSolidityVerifier","verificationKey","abiVersion","export_solidity_verifier","generateProof","witness","provingKey","generate_proof","verify","proof"],"mappings":"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","sourcesContent":["const getAbsolutePath = (basePath, relativePath) => {\n    if (relativePath[0] !== '.') {\n        return relativePath;\n    }\n    var stack = basePath.split('/');\n    var chunks = relativePath.split('/');\n    stack.pop();\n\n    for (var i = 0; i < chunks.length; i++) {\n        if (chunks[i] == '.') {\n            continue;\n        } else if (chunks[i] == '..') {\n            stack.pop();\n        } else {\n            stack.push(chunks[i]);\n        }\n    }\n    return stack.join('/');\n}\n\nconst getImportPath = (currentLocation, importLocation) => {\n    let path = getAbsolutePath(currentLocation, importLocation);\n    const extension = path.slice((path.lastIndexOf(\".\") - 1 >>> 0) + 2);\n    return extension ? path : path.concat('.zok');\n}\n\nmodule.exports = (dep) => {\n\n    const { zokrates, stdlib } = dep;\n\n    const resolveFromStdlib = (currentLocation, importLocation) => {\n        let key = getImportPath(currentLocation, importLocation);\n        let source = stdlib[key];\n        return source ? { source, location: key } : null;\n    }\n\n    return {\n        compile: (source, options = {}) => {\n            const { location = \"main.zok\", resolveCallback = () => null } = options;\n            const callback = (currentLocation, importLocation) => {\n                return resolveFromStdlib(currentLocation, importLocation) || resolveCallback(currentLocation, importLocation);\n            };\n            const { program, abi } = zokrates.compile(source, location, callback);\n            return {\n                program: Array.from(program),\n                abi\n            }\n        },\n        setup: (program) => {\n            const { vk, pk } = zokrates.setup(program);\n            return {\n                vk,\n                pk: Array.from(pk)\n            };\n        },\n        computeWitness: (artifacts, args) => {\n            return zokrates.compute_witness(artifacts, JSON.stringify(Array.from(args)));\n        },\n        exportSolidityVerifier: (verificationKey, abiVersion) => {\n            return zokrates.export_solidity_verifier(verificationKey, abiVersion);\n        },\n        generateProof: (program, witness, provingKey) => {\n            return zokrates.generate_proof(program, witness, provingKey);\n        },\n        verify: (verificationKey, proof) => {\n            return zokrates.verify(verificationKey, proof);\n        }\n    }\n};"]},"metadata":{},"sourceType":"script"}